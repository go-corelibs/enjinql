// Code generated by Participle. DO NOT EDIT.
package enjinql

import (
	"fmt"
	"io"
	"regexp/syntax"
	"strings"
	"sync"
	"unicode/utf8"

	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

var _ syntax.Op
var _ fmt.State

const _ = utf8.RuneError

var gGeneratedBackRefCache sync.Map
var gGeneratedLexer lexer.Definition = lexergGeneratedDefinitionImpl{}

type lexergGeneratedDefinitionImpl struct{}

func (lexergGeneratedDefinitionImpl) Symbols() map[string]lexer.TokenType {
	return map[string]lexer.TokenType{
		"EOF":         -1,
		"Float":       -4,
		"Ident":       -9,
		"Int":         -3,
		"Keyword":     -8,
		"Operator":    -6,
		"Placeholder": -2,
		"Punctuation": -7,
		"String":      -5,
		"whitespace":  -10,
	}
}

func (lexergGeneratedDefinitionImpl) LexString(filename string, s string) (lexer.Lexer, error) {
	return &lexergGeneratedImpl{
		s: s,
		pos: lexer.Position{
			Filename: filename,
			Line:     1,
			Column:   1,
		},
		states: []lexergGeneratedState{{name: "Root"}},
	}, nil
}

func (d lexergGeneratedDefinitionImpl) LexBytes(filename string, b []byte) (lexer.Lexer, error) {
	return d.LexString(filename, string(b))
}

func (d lexergGeneratedDefinitionImpl) Lex(filename string, r io.Reader) (lexer.Lexer, error) {
	s := &strings.Builder{}
	_, err := io.Copy(s, r)
	if err != nil {
		return nil, err
	}
	return d.LexString(filename, s.String())
}

type lexergGeneratedState struct {
	name   string
	groups []string
}

type lexergGeneratedImpl struct {
	s      string
	p      int
	pos    lexer.Position
	states []lexergGeneratedState
}

func (l *lexergGeneratedImpl) Next() (lexer.Token, error) {
	if l.p == len(l.s) {
		return lexer.EOFToken(l.pos), nil
	}
	var (
		state  = l.states[len(l.states)-1]
		groups []int
		sym    lexer.TokenType
	)
	switch state.name {
	case "Root":
		if match := matchgGeneratedPlaceholder(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -2
			groups = match[:]
		} else if match := matchgGeneratedInt(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -3
			groups = match[:]
		} else if match := matchgGeneratedFloat(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -4
			groups = match[:]
		} else if match := matchgGeneratedString(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -5
			groups = match[:]
		} else if match := matchgGeneratedOperator(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -6
			groups = match[:]
		} else if match := matchgGeneratedPunctuation(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -7
			groups = match[:]
		} else if match := matchgGeneratedKeyword(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -8
			groups = match[:]
		} else if match := matchgGeneratedIdent(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -9
			groups = match[:]
		} else if match := matchgGeneratedwhitespace(l.s, l.p, l.states[len(l.states)-1].groups); match[1] != 0 {
			sym = -10
			groups = match[:]
		}
	}
	if groups == nil {
		sample := []rune(l.s[l.p:])
		if len(sample) > 16 {
			sample = append(sample[:16], []rune("...")...)
		}
		return lexer.Token{}, participle.Errorf(l.pos, "invalid input text %q", string(sample))
	}
	pos := l.pos
	span := l.s[groups[0]:groups[1]]
	l.p = groups[1]
	l.pos.Advance(span)
	return lexer.Token{
		Type:  sym,
		Value: span,
		Pos:   pos,
	}, nil
}

func (l *lexergGeneratedImpl) sgroups(match []int) []string {
	sgroups := make([]string, len(match)/2)
	for i := 0; i < len(match)-1; i += 2 {
		sgroups[i/2] = l.s[l.p+match[i] : l.p+match[i+1]]
	}
	return sgroups
}

// \{[0-9]+\}
func matchgGeneratedPlaceholder(s string, p int, backrefs []string) (groups [2]int) {
	// \{ (Literal)
	l0 := func(s string, p int) int {
		if p < len(s) && s[p] == '{' {
			return p + 1
		}
		return -1
	}
	// [0-9] (CharClass)
	l1 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '0' && rn <= '9':
			return p + 1
		}
		return -1
	}
	// [0-9]+ (Plus)
	l2 := func(s string, p int) int {
		if p = l1(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l1(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// \} (Literal)
	l3 := func(s string, p int) int {
		if p < len(s) && s[p] == '}' {
			return p + 1
		}
		return -1
	}
	// \{[0-9]+\} (Concat)
	l4 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l2(s, p); p == -1 {
			return -1
		}
		if p = l3(s, p); p == -1 {
			return -1
		}
		return p
	}
	np := l4(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// \b([0-9]+)\b
func matchgGeneratedInt(s string, p int, backrefs []string) (groups [4]int) {
	// \b (WordBoundary)
	l0 := func(s string, p int) int {
		var l, u rune = -1, -1
		if p == 0 {
			if p < len(s) {
				if s[0] < utf8.RuneSelf {
					u, _ = rune(s[0]), 1
				} else {
					u, _ = utf8.DecodeRuneInString(s[0:])
				}
			}
		} else if p == len(s) {
			l, _ = utf8.DecodeLastRuneInString(s)
		} else {
			l, _ = utf8.DecodeLastRuneInString(s[0:p])
			if s[p] < utf8.RuneSelf {
				u, _ = rune(s[p]), 1
			} else {
				u, _ = utf8.DecodeRuneInString(s[p:])
			}
		}
		op := syntax.EmptyOpContext(l, u)
		if op&syntax.EmptyWordBoundary != 0 {
			return p
		}
		return -1
	}
	// [0-9] (CharClass)
	l1 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '0' && rn <= '9':
			return p + 1
		}
		return -1
	}
	// [0-9]+ (Plus)
	l2 := func(s string, p int) int {
		if p = l1(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l1(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// ([0-9]+) (Capture)
	l3 := func(s string, p int) int {
		np := l2(s, p)
		if np != -1 {
			groups[2] = p
			groups[3] = np
		}
		return np
	}
	// \b([0-9]+)\b (Concat)
	l4 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l3(s, p); p == -1 {
			return -1
		}
		if p = l0(s, p); p == -1 {
			return -1
		}
		return p
	}
	np := l4(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// \b([0-9]*\.[0-9]+)\b
func matchgGeneratedFloat(s string, p int, backrefs []string) (groups [4]int) {
	// \b (WordBoundary)
	l0 := func(s string, p int) int {
		var l, u rune = -1, -1
		if p == 0 {
			if p < len(s) {
				if s[0] < utf8.RuneSelf {
					u, _ = rune(s[0]), 1
				} else {
					u, _ = utf8.DecodeRuneInString(s[0:])
				}
			}
		} else if p == len(s) {
			l, _ = utf8.DecodeLastRuneInString(s)
		} else {
			l, _ = utf8.DecodeLastRuneInString(s[0:p])
			if s[p] < utf8.RuneSelf {
				u, _ = rune(s[p]), 1
			} else {
				u, _ = utf8.DecodeRuneInString(s[p:])
			}
		}
		op := syntax.EmptyOpContext(l, u)
		if op&syntax.EmptyWordBoundary != 0 {
			return p
		}
		return -1
	}
	// [0-9] (CharClass)
	l1 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '0' && rn <= '9':
			return p + 1
		}
		return -1
	}
	// [0-9]* (Star)
	l2 := func(s string, p int) int {
		for len(s) > p {
			if np := l1(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// \. (Literal)
	l3 := func(s string, p int) int {
		if p < len(s) && s[p] == '.' {
			return p + 1
		}
		return -1
	}
	// [0-9]+ (Plus)
	l4 := func(s string, p int) int {
		if p = l1(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l1(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// [0-9]*\.[0-9]+ (Concat)
	l5 := func(s string, p int) int {
		if p = l2(s, p); p == -1 {
			return -1
		}
		if p = l3(s, p); p == -1 {
			return -1
		}
		if p = l4(s, p); p == -1 {
			return -1
		}
		return p
	}
	// ([0-9]*\.[0-9]+) (Capture)
	l6 := func(s string, p int) int {
		np := l5(s, p)
		if np != -1 {
			groups[2] = p
			groups[3] = np
		}
		return np
	}
	// \b([0-9]*\.[0-9]+)\b (Concat)
	l7 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l6(s, p); p == -1 {
			return -1
		}
		if p = l0(s, p); p == -1 {
			return -1
		}
		return p
	}
	np := l7(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// ('(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:\\`|[^`])*`)
func matchgGeneratedString(s string, p int, backrefs []string) (groups [4]int) {
	// ' (Literal)
	l0 := func(s string, p int) int {
		if p < len(s) && s[p] == '\'' {
			return p + 1
		}
		return -1
	}
	// \\' (Literal)
	l1 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "\\'" {
			return p + 2
		}
		return -1
	}
	// [^'] (CharClass)
	l2 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		switch {
		case rn >= '\x00' && rn <= '&':
			return p + 1
		case rn >= '(' && rn <= '\U0010ffff':
			return p + n
		}
		return -1
	}
	// \\'|[^'] (Alternate)
	l3 := func(s string, p int) int {
		if np := l1(s, p); np != -1 {
			return np
		}
		if np := l2(s, p); np != -1 {
			return np
		}
		return -1
	}
	// (?:\\'|[^'])* (Star)
	l4 := func(s string, p int) int {
		for len(s) > p {
			if np := l3(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// '(?:\\'|[^'])*' (Concat)
	l5 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l4(s, p); p == -1 {
			return -1
		}
		if p = l0(s, p); p == -1 {
			return -1
		}
		return p
	}
	// " (Literal)
	l6 := func(s string, p int) int {
		if p < len(s) && s[p] == '"' {
			return p + 1
		}
		return -1
	}
	// \\" (Literal)
	l7 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "\\\"" {
			return p + 2
		}
		return -1
	}
	// [^"] (CharClass)
	l8 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		switch {
		case rn >= '\x00' && rn <= '!':
			return p + 1
		case rn >= '#' && rn <= '\U0010ffff':
			return p + n
		}
		return -1
	}
	// \\"|[^"] (Alternate)
	l9 := func(s string, p int) int {
		if np := l7(s, p); np != -1 {
			return np
		}
		if np := l8(s, p); np != -1 {
			return np
		}
		return -1
	}
	// (?:\\"|[^"])* (Star)
	l10 := func(s string, p int) int {
		for len(s) > p {
			if np := l9(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// "(?:\\"|[^"])*" (Concat)
	l11 := func(s string, p int) int {
		if p = l6(s, p); p == -1 {
			return -1
		}
		if p = l10(s, p); p == -1 {
			return -1
		}
		if p = l6(s, p); p == -1 {
			return -1
		}
		return p
	}
	// ` (Literal)
	l12 := func(s string, p int) int {
		if p < len(s) && s[p] == '`' {
			return p + 1
		}
		return -1
	}
	// \\` (Literal)
	l13 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "\\`" {
			return p + 2
		}
		return -1
	}
	// [^`] (CharClass)
	l14 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		switch {
		case rn >= '\x00' && rn <= '_':
			return p + 1
		case rn >= 'a' && rn <= '\U0010ffff':
			return p + n
		}
		return -1
	}
	// \\`|[^`] (Alternate)
	l15 := func(s string, p int) int {
		if np := l13(s, p); np != -1 {
			return np
		}
		if np := l14(s, p); np != -1 {
			return np
		}
		return -1
	}
	// (?:\\`|[^`])* (Star)
	l16 := func(s string, p int) int {
		for len(s) > p {
			if np := l15(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// `(?:\\`|[^`])*` (Concat)
	l17 := func(s string, p int) int {
		if p = l12(s, p); p == -1 {
			return -1
		}
		if p = l16(s, p); p == -1 {
			return -1
		}
		if p = l12(s, p); p == -1 {
			return -1
		}
		return p
	}
	// '(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:\\`|[^`])*` (Alternate)
	l18 := func(s string, p int) int {
		if np := l5(s, p); np != -1 {
			return np
		}
		if np := l11(s, p); np != -1 {
			return np
		}
		if np := l17(s, p); np != -1 {
			return np
		}
		return -1
	}
	// ('(?:\\'|[^'])*'|"(?:\\"|[^"])*"|`(?:\\`|[^`])*`) (Capture)
	l19 := func(s string, p int) int {
		np := l18(s, p)
		if np != -1 {
			groups[2] = p
			groups[3] = np
		}
		return np
	}
	np := l19(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// (==|!=|\^=|\$=|~=|\*=|<=|>=|<>|[<>])
func matchgGeneratedOperator(s string, p int, backrefs []string) (groups [4]int) {
	// == (Literal)
	l0 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "==" {
			return p + 2
		}
		return -1
	}
	// != (Literal)
	l1 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "!=" {
			return p + 2
		}
		return -1
	}
	// \^= (Literal)
	l2 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "^=" {
			return p + 2
		}
		return -1
	}
	// \$= (Literal)
	l3 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "$=" {
			return p + 2
		}
		return -1
	}
	// ~= (Literal)
	l4 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "~=" {
			return p + 2
		}
		return -1
	}
	// \*= (Literal)
	l5 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "*=" {
			return p + 2
		}
		return -1
	}
	// <= (Literal)
	l6 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "<=" {
			return p + 2
		}
		return -1
	}
	// >= (Literal)
	l7 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == ">=" {
			return p + 2
		}
		return -1
	}
	// <> (Literal)
	l8 := func(s string, p int) int {
		if p+2 <= len(s) && s[p:p+2] == "<>" {
			return p + 2
		}
		return -1
	}
	// [<>] (CharClass)
	l9 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		if rn == '<' || rn == '>' {
			return p + 1
		}
		return -1
	}
	// ==|!=|\^=|\$=|~=|\*=|<=|>=|<>|[<>] (Alternate)
	l10 := func(s string, p int) int {
		if np := l0(s, p); np != -1 {
			return np
		}
		if np := l1(s, p); np != -1 {
			return np
		}
		if np := l2(s, p); np != -1 {
			return np
		}
		if np := l3(s, p); np != -1 {
			return np
		}
		if np := l4(s, p); np != -1 {
			return np
		}
		if np := l5(s, p); np != -1 {
			return np
		}
		if np := l6(s, p); np != -1 {
			return np
		}
		if np := l7(s, p); np != -1 {
			return np
		}
		if np := l8(s, p); np != -1 {
			return np
		}
		if np := l9(s, p); np != -1 {
			return np
		}
		return -1
	}
	// (==|!=|\^=|\$=|~=|\*=|<=|>=|<>|[<>]) (Capture)
	l11 := func(s string, p int) int {
		np := l10(s, p)
		if np != -1 {
			groups[2] = p
			groups[3] = np
		}
		return np
	}
	np := l11(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// [!\(-\),\.;]
func matchgGeneratedPunctuation(s string, p int, backrefs []string) (groups [2]int) {
	// [!\(-\),\.;] (CharClass)
	l0 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn == '!':
			return p + 1
		case rn >= '(' && rn <= ')':
			return p + 1
		case rn == ',':
			return p + 1
		case rn == '.':
			return p + 1
		case rn == ';':
			return p + 1
		}
		return -1
	}
	np := l0(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// \b((?i:DISTINCT)|(?i:LOOKUP)|(?i:OFFSET)|(?i:WITHIN)|(?i:RANDOM)|(?i:QUERY)|(?i:COUNT)|(?i:FALSE)|(?i:ORDER)|(?i:LIMIT)|(?i:DESC)|(?i:LIKE)|(?i:TRUE)|(?i:NULL)|(?i:A)(?:(?i:ND)|(?i:SC))|(?i:DSC)|(?i:N)(?:(?i:OT)|(?i:IL))|(?i:AS)|(?i:BY)|(?i:IN)|(?i:OR)|(?i:SW)|(?i:EW)|(?i:C)[FSfsſ])\b
func matchgGeneratedKeyword(s string, p int, backrefs []string) (groups [4]int) {
	// \b (WordBoundary)
	l0 := func(s string, p int) int {
		var l, u rune = -1, -1
		if p == 0 {
			if p < len(s) {
				if s[0] < utf8.RuneSelf {
					u, _ = rune(s[0]), 1
				} else {
					u, _ = utf8.DecodeRuneInString(s[0:])
				}
			}
		} else if p == len(s) {
			l, _ = utf8.DecodeLastRuneInString(s)
		} else {
			l, _ = utf8.DecodeLastRuneInString(s[0:p])
			if s[p] < utf8.RuneSelf {
				u, _ = rune(s[p]), 1
			} else {
				u, _ = utf8.DecodeRuneInString(s[p:])
			}
		}
		op := syntax.EmptyOpContext(l, u)
		if op&syntax.EmptyWordBoundary != 0 {
			return p
		}
		return -1
	}
	// (?i:DISTINCT) (Literal)
	l1 := func(s string, p int) int {
		if p+8 <= len(s) && strings.EqualFold(s[p:p+8], "DISTINCT") {
			return p + 8
		}
		return -1
	}
	// (?i:LOOKUP) (Literal)
	l2 := func(s string, p int) int {
		if p+6 <= len(s) && strings.EqualFold(s[p:p+6], "LOOKUP") {
			return p + 6
		}
		return -1
	}
	// (?i:OFFSET) (Literal)
	l3 := func(s string, p int) int {
		if p+6 <= len(s) && strings.EqualFold(s[p:p+6], "OFFSET") {
			return p + 6
		}
		return -1
	}
	// (?i:WITHIN) (Literal)
	l4 := func(s string, p int) int {
		if p+6 <= len(s) && strings.EqualFold(s[p:p+6], "WITHIN") {
			return p + 6
		}
		return -1
	}
	// (?i:RANDOM) (Literal)
	l5 := func(s string, p int) int {
		if p+6 <= len(s) && strings.EqualFold(s[p:p+6], "RANDOM") {
			return p + 6
		}
		return -1
	}
	// (?i:QUERY) (Literal)
	l6 := func(s string, p int) int {
		if p+5 <= len(s) && strings.EqualFold(s[p:p+5], "QUERY") {
			return p + 5
		}
		return -1
	}
	// (?i:COUNT) (Literal)
	l7 := func(s string, p int) int {
		if p+5 <= len(s) && strings.EqualFold(s[p:p+5], "COUNT") {
			return p + 5
		}
		return -1
	}
	// (?i:FALSE) (Literal)
	l8 := func(s string, p int) int {
		if p+5 <= len(s) && strings.EqualFold(s[p:p+5], "FALSE") {
			return p + 5
		}
		return -1
	}
	// (?i:ORDER) (Literal)
	l9 := func(s string, p int) int {
		if p+5 <= len(s) && strings.EqualFold(s[p:p+5], "ORDER") {
			return p + 5
		}
		return -1
	}
	// (?i:LIMIT) (Literal)
	l10 := func(s string, p int) int {
		if p+5 <= len(s) && strings.EqualFold(s[p:p+5], "LIMIT") {
			return p + 5
		}
		return -1
	}
	// (?i:DESC) (Literal)
	l11 := func(s string, p int) int {
		if p+4 <= len(s) && strings.EqualFold(s[p:p+4], "DESC") {
			return p + 4
		}
		return -1
	}
	// (?i:LIKE) (Literal)
	l12 := func(s string, p int) int {
		if p+4 <= len(s) && strings.EqualFold(s[p:p+4], "LIKE") {
			return p + 4
		}
		return -1
	}
	// (?i:TRUE) (Literal)
	l13 := func(s string, p int) int {
		if p+4 <= len(s) && strings.EqualFold(s[p:p+4], "TRUE") {
			return p + 4
		}
		return -1
	}
	// (?i:NULL) (Literal)
	l14 := func(s string, p int) int {
		if p+4 <= len(s) && strings.EqualFold(s[p:p+4], "NULL") {
			return p + 4
		}
		return -1
	}
	// (?i:A) (Literal)
	l15 := func(s string, p int) int {
		if p+1 <= len(s) && strings.EqualFold(s[p:p+1], "A") {
			return p + 1
		}
		return -1
	}
	// (?i:ND) (Literal)
	l16 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "ND") {
			return p + 2
		}
		return -1
	}
	// (?i:SC) (Literal)
	l17 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "SC") {
			return p + 2
		}
		return -1
	}
	// (?i:ND)|(?i:SC) (Alternate)
	l18 := func(s string, p int) int {
		if np := l16(s, p); np != -1 {
			return np
		}
		if np := l17(s, p); np != -1 {
			return np
		}
		return -1
	}
	// (?i:A)(?:(?i:ND)|(?i:SC)) (Concat)
	l19 := func(s string, p int) int {
		if p = l15(s, p); p == -1 {
			return -1
		}
		if p = l18(s, p); p == -1 {
			return -1
		}
		return p
	}
	// (?i:DSC) (Literal)
	l20 := func(s string, p int) int {
		if p+3 <= len(s) && strings.EqualFold(s[p:p+3], "DSC") {
			return p + 3
		}
		return -1
	}
	// (?i:N) (Literal)
	l21 := func(s string, p int) int {
		if p+1 <= len(s) && strings.EqualFold(s[p:p+1], "N") {
			return p + 1
		}
		return -1
	}
	// (?i:OT) (Literal)
	l22 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "OT") {
			return p + 2
		}
		return -1
	}
	// (?i:IL) (Literal)
	l23 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "IL") {
			return p + 2
		}
		return -1
	}
	// (?i:OT)|(?i:IL) (Alternate)
	l24 := func(s string, p int) int {
		if np := l22(s, p); np != -1 {
			return np
		}
		if np := l23(s, p); np != -1 {
			return np
		}
		return -1
	}
	// (?i:N)(?:(?i:OT)|(?i:IL)) (Concat)
	l25 := func(s string, p int) int {
		if p = l21(s, p); p == -1 {
			return -1
		}
		if p = l24(s, p); p == -1 {
			return -1
		}
		return p
	}
	// (?i:AS) (Literal)
	l26 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "AS") {
			return p + 2
		}
		return -1
	}
	// (?i:BY) (Literal)
	l27 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "BY") {
			return p + 2
		}
		return -1
	}
	// (?i:IN) (Literal)
	l28 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "IN") {
			return p + 2
		}
		return -1
	}
	// (?i:OR) (Literal)
	l29 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "OR") {
			return p + 2
		}
		return -1
	}
	// (?i:SW) (Literal)
	l30 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "SW") {
			return p + 2
		}
		return -1
	}
	// (?i:EW) (Literal)
	l31 := func(s string, p int) int {
		if p+2 <= len(s) && strings.EqualFold(s[p:p+2], "EW") {
			return p + 2
		}
		return -1
	}
	// (?i:C) (Literal)
	l32 := func(s string, p int) int {
		if p+1 <= len(s) && strings.EqualFold(s[p:p+1], "C") {
			return p + 1
		}
		return -1
	}
	// [FSfsſ] (CharClass)
	l33 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		var (
			rn rune
			n  int
		)
		if s[p] < utf8.RuneSelf {
			rn, n = rune(s[p]), 1
		} else {
			rn, n = utf8.DecodeRuneInString(s[p:])
		}
		switch {
		case rn == 'F':
			return p + 1
		case rn == 'S':
			return p + 1
		case rn == 'f':
			return p + 1
		case rn == 's':
			return p + 1
		case rn == 'ſ':
			return p + n
		}
		return -1
	}
	// (?i:C)[FSfsſ] (Concat)
	l34 := func(s string, p int) int {
		if p = l32(s, p); p == -1 {
			return -1
		}
		if p = l33(s, p); p == -1 {
			return -1
		}
		return p
	}
	// (?i:DISTINCT)|(?i:LOOKUP)|(?i:OFFSET)|(?i:WITHIN)|(?i:RANDOM)|(?i:QUERY)|(?i:COUNT)|(?i:FALSE)|(?i:ORDER)|(?i:LIMIT)|(?i:DESC)|(?i:LIKE)|(?i:TRUE)|(?i:NULL)|(?i:A)(?:(?i:ND)|(?i:SC))|(?i:DSC)|(?i:N)(?:(?i:OT)|(?i:IL))|(?i:AS)|(?i:BY)|(?i:IN)|(?i:OR)|(?i:SW)|(?i:EW)|(?i:C)[FSfsſ] (Alternate)
	l35 := func(s string, p int) int {
		if np := l1(s, p); np != -1 {
			return np
		}
		if np := l2(s, p); np != -1 {
			return np
		}
		if np := l3(s, p); np != -1 {
			return np
		}
		if np := l4(s, p); np != -1 {
			return np
		}
		if np := l5(s, p); np != -1 {
			return np
		}
		if np := l6(s, p); np != -1 {
			return np
		}
		if np := l7(s, p); np != -1 {
			return np
		}
		if np := l8(s, p); np != -1 {
			return np
		}
		if np := l9(s, p); np != -1 {
			return np
		}
		if np := l10(s, p); np != -1 {
			return np
		}
		if np := l11(s, p); np != -1 {
			return np
		}
		if np := l12(s, p); np != -1 {
			return np
		}
		if np := l13(s, p); np != -1 {
			return np
		}
		if np := l14(s, p); np != -1 {
			return np
		}
		if np := l19(s, p); np != -1 {
			return np
		}
		if np := l20(s, p); np != -1 {
			return np
		}
		if np := l25(s, p); np != -1 {
			return np
		}
		if np := l26(s, p); np != -1 {
			return np
		}
		if np := l27(s, p); np != -1 {
			return np
		}
		if np := l28(s, p); np != -1 {
			return np
		}
		if np := l29(s, p); np != -1 {
			return np
		}
		if np := l30(s, p); np != -1 {
			return np
		}
		if np := l31(s, p); np != -1 {
			return np
		}
		if np := l34(s, p); np != -1 {
			return np
		}
		return -1
	}
	// ((?i:DISTINCT)|(?i:LOOKUP)|(?i:OFFSET)|(?i:WITHIN)|(?i:RANDOM)|(?i:QUERY)|(?i:COUNT)|(?i:FALSE)|(?i:ORDER)|(?i:LIMIT)|(?i:DESC)|(?i:LIKE)|(?i:TRUE)|(?i:NULL)|(?i:A)(?:(?i:ND)|(?i:SC))|(?i:DSC)|(?i:N)(?:(?i:OT)|(?i:IL))|(?i:AS)|(?i:BY)|(?i:IN)|(?i:OR)|(?i:SW)|(?i:EW)|(?i:C)[FSfsſ]) (Capture)
	l36 := func(s string, p int) int {
		np := l35(s, p)
		if np != -1 {
			groups[2] = p
			groups[3] = np
		}
		return np
	}
	// \b((?i:DISTINCT)|(?i:LOOKUP)|(?i:OFFSET)|(?i:WITHIN)|(?i:RANDOM)|(?i:QUERY)|(?i:COUNT)|(?i:FALSE)|(?i:ORDER)|(?i:LIMIT)|(?i:DESC)|(?i:LIKE)|(?i:TRUE)|(?i:NULL)|(?i:A)(?:(?i:ND)|(?i:SC))|(?i:DSC)|(?i:N)(?:(?i:OT)|(?i:IL))|(?i:AS)|(?i:BY)|(?i:IN)|(?i:OR)|(?i:SW)|(?i:EW)|(?i:C)[FSfsſ])\b (Concat)
	l37 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l36(s, p); p == -1 {
			return -1
		}
		if p = l0(s, p); p == -1 {
			return -1
		}
		return p
	}
	np := l37(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// \b([A-Z_a-z][0-9A-Z_a-z]*)\b
func matchgGeneratedIdent(s string, p int, backrefs []string) (groups [4]int) {
	// \b (WordBoundary)
	l0 := func(s string, p int) int {
		var l, u rune = -1, -1
		if p == 0 {
			if p < len(s) {
				if s[0] < utf8.RuneSelf {
					u, _ = rune(s[0]), 1
				} else {
					u, _ = utf8.DecodeRuneInString(s[0:])
				}
			}
		} else if p == len(s) {
			l, _ = utf8.DecodeLastRuneInString(s)
		} else {
			l, _ = utf8.DecodeLastRuneInString(s[0:p])
			if s[p] < utf8.RuneSelf {
				u, _ = rune(s[p]), 1
			} else {
				u, _ = utf8.DecodeRuneInString(s[p:])
			}
		}
		op := syntax.EmptyOpContext(l, u)
		if op&syntax.EmptyWordBoundary != 0 {
			return p
		}
		return -1
	}
	// [A-Z_a-z] (CharClass)
	l1 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= 'A' && rn <= 'Z':
			return p + 1
		case rn == '_':
			return p + 1
		case rn >= 'a' && rn <= 'z':
			return p + 1
		}
		return -1
	}
	// [0-9A-Z_a-z] (CharClass)
	l2 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '0' && rn <= '9':
			return p + 1
		case rn >= 'A' && rn <= 'Z':
			return p + 1
		case rn == '_':
			return p + 1
		case rn >= 'a' && rn <= 'z':
			return p + 1
		}
		return -1
	}
	// [0-9A-Z_a-z]* (Star)
	l3 := func(s string, p int) int {
		for len(s) > p {
			if np := l2(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	// [A-Z_a-z][0-9A-Z_a-z]* (Concat)
	l4 := func(s string, p int) int {
		if p = l1(s, p); p == -1 {
			return -1
		}
		if p = l3(s, p); p == -1 {
			return -1
		}
		return p
	}
	// ([A-Z_a-z][0-9A-Z_a-z]*) (Capture)
	l5 := func(s string, p int) int {
		np := l4(s, p)
		if np != -1 {
			groups[2] = p
			groups[3] = np
		}
		return np
	}
	// \b([A-Z_a-z][0-9A-Z_a-z]*)\b (Concat)
	l6 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		if p = l5(s, p); p == -1 {
			return -1
		}
		if p = l0(s, p); p == -1 {
			return -1
		}
		return p
	}
	np := l6(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}

// [\t-\n\f-\r ]+
func matchgGeneratedwhitespace(s string, p int, backrefs []string) (groups [2]int) {
	// [\t-\n\f-\r ] (CharClass)
	l0 := func(s string, p int) int {
		if len(s) <= p {
			return -1
		}
		rn := s[p]
		switch {
		case rn >= '\t' && rn <= '\n':
			return p + 1
		case rn >= '\f' && rn <= '\r':
			return p + 1
		case rn == ' ':
			return p + 1
		}
		return -1
	}
	// [\t-\n\f-\r ]+ (Plus)
	l1 := func(s string, p int) int {
		if p = l0(s, p); p == -1 {
			return -1
		}
		for len(s) > p {
			if np := l0(s, p); np == -1 {
				return p
			} else {
				p = np
			}
		}
		return p
	}
	np := l1(s, p)
	if np == -1 {
		return
	}
	groups[0] = p
	groups[1] = np
	return
}
